Introduction
This guide breaks down the "infinite agentic loop" technique into a clear, step-by-step process. The goal is to create a system where an AI agent can autonomously generate a vast number of variations for a specific task, such as creating UI components. This is achieved by using two core prompt files: one that defines the plan (the "spec") and one that acts as the engine to execute that plan repeatedly (the "infinite" prompt).
Prerequisites
An Advanced AI Coding Assistant: You'll need a tool similar to Claude Code, which is an AI that can read local files, write new files, and execute commands or other prompts from within a "chat" or command-line interface.
Basic Command-Line Familiarity: You should be comfortable navigating directories and running commands in a terminal.
Project Folder: Create a dedicated folder for your project to keep your files organized. Inside this folder, create an output directory where the AI will save its generated files.
Step 1: Create the "Spec" File (The Blueprint)
The "spec" file is the master plan. It's a Markdown file (.md) that tells the AI what to create. It should be detailed and clear, acting as a Product Requirements Document (PRD) for each sub-agent that gets created.
Create a file named spec.md in your project folder.
Write the plan. Your plan should guide the AI. The key is to ask for a unique combination or novel invention to ensure the outputs are different each time.
Example spec.md:
# Plan: Invent a Novel UI Component

## Core Mission
Your task is to invent a new, fully-functional, and aesthetically pleasing UI component. The component must be self-contained in a single file (HTML with inline CSS and JS).

## Creative Mandate
You must combine the functionality of two different types of UI elements to create something entirely new. You also need to apply a unique and creative visual theme.

## Requirements
1.  **Functionality:** Combine a **data table** with interactive **charts**. For example, when a user clicks on a row in the table, a chart below it dynamically updates to visualize that row's data.
2.  **Theme:** Apply a "Bioluminescent Grotto" theme. This means using dark backgrounds, glowing text and borders, and soft, organic shapes.
3.  **Uniqueness:** Do not simply copy existing designs. The layout, interaction, and visual elements must be your own unique interpretation of this concept.
4.  **Code:** The final output must be a single HTML file with vanilla JavaScript and CSS. Do not use external libraries.


Step 2: Create the "Infinite" Prompt (The Engine)
The "infinite" prompt is the engine that drives the loop. It reads the spec.md file and continuously spawns new agents, telling each one to follow the plan.
Create a file named infinite.md in your project folder.
Write the engine's logic. This prompt will use variables that your AI tool can interpret. The structure is designed to create and manage the loop.
Example infinite.md:
# Agentic Engine: Infinite Generation Loop

## Variables
This prompt accepts the following parameters:
- `spec_file`: The path to the spec file (e.g., `spec.md`).
- `output_dir`: The directory to save the generated files (e.g., `output`).
- `count`: The number of agents to run. Use the keyword "infinite" to run continuously.

## Step 1: Read the Master Plan
Read the entire content of the file specified in the `spec_file` variable. Store this content in a variable called `master_plan`.

## Step 2: Initiate the Loop
Based on the `count` variable, start the generation process. If `count` is "infinite", run an endless loop. If it's a number, loop that many times.

For each iteration of the loop (from 1 to `count`):

1.  **Create a Unique Sub-Directory:** Create a new sub-directory inside `output_dir`. Name it `generation_{iteration_number}` (e.g., `output/generation_1`, `output/generation_2`).

2.  **Spawn a Sub-Agent:** Launch a new, parallel agent instance with the following instructions:
    
    ---
    
    **Sub-Agent Task (Iteration: {iteration_number})**
    
    **Your Goal:** You are an expert software engineer. Your mission is to execute the following plan and save the resulting file in this directory: `{output_dir}/generation_{iteration_number}/`
    
    **Uniqueness Mandate:** It is critical that your output is a completely unique and creative interpretation of the plan. Do not produce the same result as other agents.
    
    **Master Plan:**
    ```
    {master_plan}
    ```
    ---

## Step 3: Continue
Continue this process until the specified `count` is reached or until I manually stop you. Run the sub-agents in parallel to maximize output.


Step 3: Execute the Loop
Now you will use your AI coding assistant to run the infinite.md prompt. Many tools allow for custom commands or have a way to make the AI read a file and follow its instructions. In the video, a custom /infinite command was created.
Open your AI coding assistant in your terminal, with the current directory being your project folder.
Run the command. You need to pass the variables defined in infinite.md to the command.
Example Command (based on the video's syntax):
/agent --prompt-file infinite.md --spec_file spec.md --output_dir output --count infinite


Your tool's specific syntax might be different. You might need to tell it: "Run the instructions in infinite.md. Use spec.md as the spec_file, output as the output_dir, and infinite for the count."
Step 4: Monitor the Process
Once you execute the command, the AI agent should:
Acknowledge that it is starting the process described in infinite.md.
Begin creating sub-directories within your output folder (e.g., generation_1, generation_2, etc.).
Inside each of those sub-directories, it will save the HTML file it generates based on the spec.md.
You can open these files as they are created to see the results in real-time.
Step 5: Stop the Loop
Since the loop is designed to be infinite, it will run until it hits a limitation (like its context window or memory) or until you stop it. You will need to manually stop the process in your terminal (usually with Ctrl + C). Be mindful that running these processes can consume a lot of resources or credits, depending on the service you are using.

—
The video demonstrates two primary prompts used in an infinite agentic loop. Here's a breakdown of each:
1. Infinite Prompt (infinite.md)
This prompt acts as the engine for the "Claude Code" agent, enabling it to generate multiple sub-agents that work in parallel. It includes the following elements:
Variables:
spec_file: The path to the markdown specification file.
output_dir: The directory where the generated iterations are saved.
count: The number of iterations to perform (can be a specific number or "infinite").
Argument Parsing: The agent is designed to parse command-line arguments, including the spec_file, output_dir, and count.
Phases of the Infinite Agentic Loop:
Phase 1: Specification Analysis [04:24]: The agent reads and analyzes the provided specification file to understand the task's requirements, format, and constraints.
Phase 2: Output Directory Reconnaissance [05:07]: The agent examines the output directory to understand the current state of the project, including existing files and their content.
Phase 3: Iteration Strategy [05:11]: This phase involves planning the next iteration, ensuring it's unique and builds upon previous versions.
Phase 4: Parallel Agent Coordination [05:14]: This phase focuses on deploying and managing multiple sub-agents to generate different iterations simultaneously. It includes strategies for distributing tasks and assigning specific requirements to each sub-agent.
Phase 5: Infinite Mode Orchestration [05:52]: This phase manages the continuous generation of new iterations when the count is set to "infinite," including strategies for handling context capacity and ensuring progressive sophistication.
Context Optimization: The main agent keeps track of the generated iterations and summarizes them to avoid exceeding context limits.
2. Spec File (invent_new_ui_v3.md)
This prompt provides the specific instructions for the agentic loop, outlining the task the agents need to perform.
Core Challenge: The primary goal is to create unique UI components by combining multiple existing UI elements into a single, efficient solution.
Output Requirements: The output should be a dynamically designed language that is both memorable and has a distinct personality.
File Naming: The generated files should follow the format ui_hybrid_[iteration_number].html.
Content Structure: Each output should be a self-contained HTML file with a themed, multi-functional component.
Design Dimensions:
Theme Categories [07:31]: The prompt provides a list of themes for inspiration, including Organic Natures, Digital Minimalism, and Cyberpunk Futures.
Output Requirements: The generated UI components should have coordinated behavior, theme-consistent animations, and smart state management.
— 
Full video transcript:
engineers I think I just broke Clawude Code the best agent coding tool in the game check this out and you tell me the amount of value you can create in a single prompt is incredible the amount of value you can create in two prompts is insanely mindblowing and not well understood let me show you exactly what I mean here I'm running a clawed code infinite agentic loop now what does that mean and what does that look like inside of this five directory codebase I'm generating infinite self-contained UIs that self-improve on each set how is this possible if I open up go into commands you can see I have this infinite.md prompt that's fueling this claw code agent that's fired off five sub agents you can see them all working here live right now this one just wrote 1,000 lines we have another thousand lines here one tool use three one two and you can see here this is wave two with five agents in parallel and more are getting queued up right now you can see it just finished wave two how can just two prompts make Cloud Code run forever you can see wave 3 is getting set up right now iterations 16 through 20 if we scroll down here you can see a new set of iterations loaded up check out this task list right this is going to just keep running back to the question how is this possible this is enabled by an infinite agentic loop this powerful pattern is fueled by just two prompts it's fueled by the infinite prompt that we're going to get into in just a second and of course your spec your plan your PRD so if we open this up a little bit you can see here I have just three specs where we're inventing some new UIs i have three versions of them let's go ahead and kick off another infinite agentic loop like this and while it's dedicating work to multiple sub agents for us we can talk about how you can use this to generate a virtually unlimited set of solutions for a specific problem i'll create a new terminal instance let's fire up cloud code here and let's update the model i want to fire this off on Opus very clearly state-of-the-art model and then we'll use the infinite custom slash command here i'll type slashinfinite and you can see here we have the infinite agentic loop command i'll hit tab here and now we need to pass in a few variables into this so the first parameter is the plan we want to fire off i'm going to go ahead copy this get the path to this paste it in here you can see we're still running in the background right agent 16 through 20 still running here it takes a new directory so you can see our first agent is operating in the source directory let's set this directory to source_infinite and then lastly it takes a count or the information dense keyword infinite we're going to of course pass in infinite so we're going to kick this off and now we're going to have two agents running in parallel and so we can see here our second infinite agentic loop is starting to fire off here so if I close this and open up the second directory you can see that got created here in our plan you can see cloud code writing up this plan for infinite generation we need to dive into the prompt this is the most important thing it's the pattern here that's so valuable let's go ahead and dive in here and understand how this infinite agentic loop works with our two prompt system and then let's talk about how this breaks down if you've been using longunning cloud code jobs you already know exactly how this breaks there's a natural limit here that we're starting to bump into over and over and over and it completely breaks this infinite agentic loop workflow let's start with the infinite prompt so we have our initial command and then we have a really important part of this the variables with cloud code custom/comands you can pass in arguments like this and they'll be placed in position our first argument gets replaced with spec and then we get infinite source and then we get infinite so this gets replaced and then we can use these variables throughout this prompt and the cloud 4 series is smart enough to know that it should replace the variables we placed in here with the actual variables passed in right so you can see the spec file throughout this prompt and you can see the output directory as well then we have count which is going to be one to n or of course infinite you can see here in this first step of the infinite agentic loop prompt we're reading the spec file this is a really interesting pattern we're treating prompts right our specs as first class citizens that can be passed in to other prompts okay this is a really powerful technique there's a lot of value here that's untapped we explored this a little bit in our parallel agent decoding with git work trees video we put out a couple weeks ago what we're doing here is a little different because we're running infinitely and we're generating a single file although to be completely clear you know we could rewrite this prompt to generate any set of files so we have argument parsing our agent is going to first read the spec file to understand what's going on then it's going to understand where it's going to output all these files then it's going to fire off parallel agents in groups of five this is going to speed up the output of our agent our first round files have already been created for that infinite loop and then this is really important we're actually specifying what each sub aent receives okay okay so it's getting the spec it's getting the directory it's getting its iteration number right you can see they all have their own iteration number and it's getting their uniqueness directive right we want these all to be unique we want each example to grow on each other this is really cool so here we're actually passing in a prompt for our sub aents so that's what's getting written out here right this is a concise prompt for the sub aent and then we have you know phase five we're just kind of continuing down the line infinite cycle and then I have this line in here i'm not 100% sure if this works i don't know if Claude can see the end of its context window but it seems to work okay evaluate context capacity remaining if sufficient continue with next wave if approaching limits complete and finalize right so this is where this pattern completely breaks clog code you can't keep running this it's going to hit the context window of course we don't actually have infinite context windows this will generate you know some 20 30 files or sets um depending on your setup all right all right so then we're going to just continue along the lines here there are some details at the bottom here not all this matters as you can see here I am writing these prompts now with agents we're entering this interesting zone where you want to be writing prompts that write the prompts for you you can see here you know both of our lists here are continuing to expand we now have 10 hybrid UIs inside of Source Infinite let's go ahead and actually look at what the heck is getting generated here right you know just to briefly describe the prompt that we're passing in right so we have our spec file that we're passing in to our infinite agentic loop prompt we're saying invent new UI v3 and what we're doing here is we're creating uniquely themed UI components that combines multiple existing UIs into one elegant solution okay and that's that's basically it that's a key idea of what we're doing here and I'm using UI as a example just like with our parallel agent decoding video with git work trees ui is just the simplest way to show off a powerful pattern like this you know we're specifying that naming scheme here with the iteration and then we have a kind of rough HTML structure that's all self-contained into a single file so let's go and open this up let's see what this looks like right so if we open up a terminal here and we get the path to one of these files we can say uh Chrome and then open up one of these files check this out neural implant registry um very interesting this is a classified database access terminal very clearly it's just a table right so this is kind of interesting it's got a really cool unique theme to it let's see what we can do here so we can search nice echo cerebra max okay great so we can search across columns we can sort that looks great status filters active risk level here i'm constantly impressed with the caliber of code that the Cloud 4 series is producing now it's just kind of mind-blowing that not only was it able to launch off this it did five versions at the same time right you and I we really have access to premium compute that we can now scale up infinitely uh with this pattern right very cool UI let's go on to another example right adaptive flow UI liquid metal so obviously some UI issues here but this is just a simple UI it looks like nothing special oh interesting that just adapted very interesting i did not expect that so it's actually creating additional UI here based on what we type in oh I like this kind of error state look at this it's errored right here right this is not a true email address and we do get email autocomplete here very cool and you can see we also have a progress bar here at the bottom in particular I like this like active state let's go ahead and look at another UI that was generated for us again this is all happening in parallel in the background you know this compute is solving this problem for us at scale creating many many versions right what do we have some 20 um yeah 50 versions now with two parallel infinite agenda coding agents this is crazy right this it's really cool very powerful obviously the real trick with this pattern is going to be to pointing it at a problem where you need multiple potential solutions okay this is the real trick with this pattern you know everything we do on the channel you need to take it and you need to point it at a problem there's a ton of value here that you can get out of this interesting interesting twoprompt infinite agentic loop pattern right we're starting to compose prompts we already know that great planning is great prompting and you know maybe that's a important thing to really highlight here right we're generating all these cool UIs um you know we can continue to just look at look look at this so interesting right we can look at UI after UI right after UI and look at this one so interesting right look at all these just interesting creative UIs there's you know a lot of likely garbage here but there's a lot of value here as well right we're literally inventing new UIs as we go along and new UI patterns right we can just keep going check this one out how cool is this okay so you know this is the power of an infinite agentic loop multiple solutions it's just going to keep going keep firing we're using a ton and ton and ton of compute here right you can see we're launching another wave of agents inside of this agent right one tool call 30k 30k 30k 2 minutes each these are shorter jobs i've run jobs that are 30 minutes plus and you can fire them all off in a subtask it's so incredible what we can do with cloud code and with the right pattern right the right prompting patterns that lets us scale compute okay so really interesting stuff there what's important what's the signal here right couple things to call out um you can pass prompts into prompts you can specify variables at the top of your files you're likely going to want multiple variables that control what happens and what gets done okay we have this infinite information dense keyword this triggers our agenda coding tool to run infinitely of course you need to phrase things you need to be more specific with how that works you can start with this prompt and modify it build it make it your own couple more key ideas this is a classic one right um we have been using plans for over a year now on the channel and every principal AI coding member you know that great planning is great prompting i sound like a broken record bringing this up for you know over half a year now but there's a reason for it okay we know that tools will change we know that models will improve you can't fixate on these things right cloud code is the very clear winner right now but it won't always be that way okay and we're going to get another model all that stuff changes what doesn't change is the principles of AI coding many of you know this is why I built principled AI coding sorry for existing members and for engineers that have already taken this but the repetition is probably important anyway it's so so important to realize that you want foundational skills that don't change with the next model with the next tool the plan right great planning is great prompting this is principle four or five this is so relevant it's increasingly important okay why is that it's because we can now scale or compute further right but how we do that is always about communicating to our agents okay cloud code is the best top agent right now for engineering why is that it's because it operates in the highest leverage environment for engineers the terminal anything you can do claw code can do and you know part of me wants to say better you know we'll debate that more in the channel as time goes on it's definitely getting there uh but you can see we're generating yet another batch of agents here okay we have this ocean file explorer very interesting but anyways refocusing here right the spec is super important because this details what we want done inside of this infinite agentic loop right so we have this really cool pattern where we're treating our prompts like you can treat functions in certain languages right you can you can pass the function into a function that's what we're doing here right the same idea transferred to this domain of agentic coding and really prompt engineering we're taking a prompt passing it in to a prompt you know the magic is obviously in the pattern of this infinite agentic loop but it's really in what you ask your spec to do right it's what you ask your agent to do there's a ton and ton of value in this pattern i hope you can see how powerful this is when do you want to use something like this look at all these UIs we have generating right we have two two uh agents going back to back here very very cool so what when do you want to use something like this you want to use a pattern like this it's very similar again to our parallel agent coding with git work trees there we cloned our entire codebase into the work tree directory so that multiple agents can work on their own directories again link for that video is going to be in the description i highly recommend you check that out but what we're doing here is so fascinating it's so powerful we're scaling our compute we're solving a specific problem with many variations of how it can be solved so when do you want to use the infinite agentic loop you want to use it when there are multiple potential solutions that you want to explore you want to use it when you're working on a hard problem that you don't know the answer to and you think that having many versions will help you get closer and so this is all stuff you would encode in your lower level prompt that the infinite agentic loop prompt will execute on right and you want to use this when this is a really really big idea uh this is like a lead researchers are doing this when you want to set up a self-improving agentic workflow that is trying to achieve some verifiable outcome that increases over time okay we've all heard about reinforcement learning you can take that idea of reinforcement learning you can take that idea of self-verifiable domains and you can embed it in an infinite agentic loop prompt like this uh this is a really really big idea more on this on the channel in the future we don't have enough time to cover that here right now but that's just really important to call out those are kind of the three big use cases for this that I can find right away i'm sure if you dig into this if you start using this you'll find uh more you know use cases for this right so pretty incredible stuff right we have two agents running in cloud code you can see I am hitting the limit i'm breaking cloud code right now okay we're running just straight out of Opus credits i am running in the cloud code max pro subscription wherever the top tier is i'm going to go ahead i'm going to stop these agents i I need a few more credits for today to um do some other engineering work i'm going to stop these here you can see we're literally infinitely generating tons and tons of solutions to this problem right that's the trick here right that's the real value prop of the infinite agentic loop you want multiple versions multiple potential futures of an answer to a problem that you have okay ui is obviously just the simplest one that's why I've showed it here a couple times on the channel um you know we can just keep looking through these different user interfaces with different ideas and themes blended together check this one out very smooth very cool um and this is all happening you know in the background with compute we're scaling up doing this again we're scaling up our compute even further beyond that's what we do on the channel every single Monday check out Principal AI coding as many of you know I am actively working on the second phase course this is the foundation i highly recommend you check this out what comes next after AI coding is of course agentic coding i'll have more details on the next generation course as we move closer to the release date looking at a Q3 launch so stay tuned for that you know this is a really powerful technique try this don't ignore this please uh for your own good um you know it's completely free a lot of the stuff I'm doing here obviously is all free for you guys link in the description to this codebase i'll save some of these generations so you can kind of really see and understand how this works but it's really about the infinite prompt take all this stuff make it your own improve on it solve your problem better than ever with compute big theme on the channel to scale your impact you scale your compute okay tune in make sure you subscribe like all that good stuff compute equals success scale your compute you win you know where to find me every single Monday stay focused and keep building 