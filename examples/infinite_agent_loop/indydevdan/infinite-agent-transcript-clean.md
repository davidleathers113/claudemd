# **Introduction: Breaking Claude Code with an Infinite Agentic Loop**

I think I just broke Claude Code, the best agent coding tool in the game. Check this out and you tell me. The amount of value you can create in a single prompt is incredible. The amount of value you can create in two prompts is insanely mind-blowing and not well understood. Let me show you exactly what I mean.

Here I'm running a Claude Code infinite agentic loop. Now, what does that mean and what does that look like? Inside of this five-directory codebase, I'm generating infinite self-contained UIs that self-improve on each set. How is this possible?

If I open up "go" into "commands," you can see I have this `infinite.md` prompt that's fueling this Claude Code agent that's fired off five sub-agents. You can see them all working here live right now. This one just wrote 1,000 lines. We have another thousand lines here. One tool use, three, one, two, and you can see here this is wave two with five agents in parallel, and more are getting queued up right now. You can see it just finished wave two.

How can just two prompts make Claude Code run forever? You can see wave three is getting set up right now, iterations 16 through 20. If we scroll down here, you can see a new set of iterations loaded up. Check out this task list, right? This is going to just keep running.

### **The Two-Prompt System**

Back to the question, how is this possible? This is enabled by an infinite agentic loop. This powerful pattern is fueled by just two prompts: the infinite prompt that we're going to get into in just a second, and of course, your spec, your plan, your PRD.

So if we open this up a little bit, you can see here I have just three specs where we're inventing some new UIs. I have three versions of them. Let's go ahead and kick off another infinite agentic loop like this, and while it's dedicating work to multiple sub-agents for us, we can talk about how you can use this to generate a virtually unlimited set of solutions for a specific problem.

I'll create a new terminal instance. Let's fire up Claude Code here and let's update the model. I want to fire this off on Opus, very clearly the state-of-the-art model. Then we'll use the infinite custom slash command here. I'll type `/infinite` and you can see here we have the "infinite agentic loop" command. I'll hit tab here, and now we need to pass in a few variables into this.

The first parameter is the plan we want to fire off. I'm going to go ahead and copy this, get the path to this, paste it in here. You can see we're still running in the background, right? Agents 16 through 20 are still running here. It takes a new directory. You can see our first agent is operating in the "source" directory. Let's set this directory to `source_infinite`. And then lastly, it takes a count or the information-dense keyword "infinite." We're going to of course pass in "infinite."

### **How the Infinite Agentic Loop Works**

So we're going to kick this off, and now we're going to have two agents running in parallel. And so we can see here our second infinite agentic loop is starting to fire off here. So if I close this and open up the second directory, you can see that got created here in our plan. You can see Claude Code writing up this plan for infinite generation.

We need to dive into the prompt. This is the most important thing. It's the pattern here that's so valuable. Let's go ahead and dive in here and understand how this infinite agentic loop works with our two-prompt system, and then let's talk about how this breaks down.

If you've been using long-running Claude Code jobs, you already know exactly how this breaks. There's a natural limit here that we're starting to bump into over and over and over, and it completely breaks this infinite agentic loop workflow.

Let's start with the infinite prompt. So we have our initial command, and then we have a really important part of this: the variables. With Claude Code custom slash commands, you can pass in arguments like this, and they'll be placed in position. Our first argument gets replaced with "spec," and then we get "infinite source," and then we get "infinite." So this gets replaced, and then we can use these variables throughout this prompt. And the Claude 4 series is smart enough to know that it should replace the variables we placed in here with the actual variables passed in, right? So you can see the "spec file" throughout this prompt, and you can see the "output directory" as well. Then we have "count," which is going to be one to N or, of course, "infinite."

### **Inside the Prompt: A Deeper Look**

You can see here in this first step of the infinite agentic loop prompt, we're reading the spec file. This is a really interesting pattern. We're treating prompts, right, our specs, as first-class citizens that can be passed into other prompts. Okay, this is a really powerful technique. There's a lot of value here that's untapped. We explored this a little bit in our "Parallel Agent Decoding with Git Worktrees" video we put out a couple of weeks ago. What we're doing here is a little different because we're running infinitely and we're generating a single file, although to be completely clear, you know, we could rewrite this prompt to generate any set of files.

So we have argument parsing. Our agent is going to first read the spec file to understand what's going on. Then it's going to understand where it's going to output all these files. Then it's going to fire off parallel agents in groups of five. This is going to speed up the output of our agent. Our first-round files have already been created for that infinite loop.

And then this is really important: we're actually specifying what each sub-agent receives. Okay, so it's getting the spec, it's getting the directory, it's getting its iteration number, right? You can see they all have their own iteration number. And it's getting their uniqueness directive, right? We want these all to be unique. We want each example to grow on each other. This is really cool.

So here we're actually passing in a prompt for our sub-agents. So that's what's getting written out here, right? This is a concise prompt for the sub-agent. And then we have, you know, phase five, we're just kind of continuing down the line, infinite cycle.

And then I have this line in here. I'm not 100% sure if this works. I don't know if Claude can see the end of its context window, but it seems to work okay. "Evaluate context capacity remaining. If sufficient, continue with the next wave. If approaching limits, complete and finalize." Right, so this is where this pattern completely breaks Claude Code. You can't keep running this. It's going to hit the context window. Of course, we don't actually have infinite context windows. This will generate, you know, some 20-30 files or sets depending on your setup. All right, so then we're going to just continue along the lines here. There are some details at the bottom here, not all of this matters.

### **The Power of Prompt Engineering**

As you can see here, I am writing these prompts now with agents. We're entering this interesting zone where you want to be writing prompts that write the prompts for you. You can see here, you know, both of our lists here are continuing to expand. We now have 10 hybrid UIs inside of "Source Infinite."

Let's go ahead and actually look at what the heck is getting generated here, right? You know, just to briefly describe the prompt that we're passing in. Right, so we have our spec file that we're passing into our infinite agentic loop prompt. We're saying, "invent new UI v3," and what we're doing here is we're creating uniquely themed UI components that combine multiple existing UIs into one elegant solution. Okay, and that's basically it. That's the key idea of what we're doing here. And I'm using UI as an example, just like with our "Parallel Agent Decoding" video with Git worktrees. UI is just the simplest way to show off a powerful pattern like this. You know, we're specifying the naming scheme here with the iteration, and then we have a kind of rough HTML structure that's all self-contained into a single file.

### **Reviewing the Generated UIs**

So let's go and open this up. Let's see what this looks like, right? So if we open up a terminal here and we get the path to one of these files, we can say, "uh, Chrome," and then open up one of these files. Check this out. "Neural Implant Registry." Um, very interesting. This is a classified database access terminal. Very clearly, it's just a table, right? So this is kind of interesting. It's got a really cool, unique theme to it. Let's see what we can do here. So we can search. Nice. "Echo Cerebra Max." Okay, great. So we can search across columns. We can sort. That looks great. Status filters: active, risk level here.

I'm constantly impressed with the caliber of code that the Claude 4 series is producing now. It's just kind of mind-blowing that not only was it able to launch off this, but it did five versions at the same time. Right, you and I, we really have access to premium compute that we can now scale up infinitely with this pattern, right? Very cool UI.

Let's go on to another example, right? "Adaptive Flow UI," "Liquid Metal." So obviously some UI issues here, but this is just a simple UI. It looks like nothing special. Oh, interesting, that just adapted. Very interesting. I did not expect that. So it's actually creating additional UI here based on what we type in. Oh, I like this kind of error state. Look at this, it's errored right here, right? This is not a true email address, and we do get email autocomplete here. Very cool. And you can see we also have a progress bar here at the bottom. In particular, I like this active state.

Let's go ahead and look at another UI that was generated for us. Again, this is all happening in parallel in the background. You know, this compute is solving this problem for us at scale, creating many, many versions, right? What do we have, some 20, um, yeah, 50 versions now with two parallel infinite agentic coding agents. This is crazy, right? This is really cool, very powerful.

### **The Trick to Using This Pattern**

Obviously, the real trick with this pattern is going to be pointing it at a problem where you need multiple potential solutions. Okay, this is the real trick with this pattern. You know, everything we do on the channel, you need to take it and you need to point it at a problem. There's a ton of value here that you can get out of this interesting, interesting two-prompt infinite agentic loop pattern, right? We're starting to compose prompts. We already know that great planning is great prompting, and you know, maybe that's an important thing to really highlight here.

Right, we're generating all these cool UIs. Um, you know, we can continue to just look at, look at this. So interesting, right? We can look at UI after UI after UI. And look at this one. So interesting, right? Look at all these just interesting, creative UIs. There's, you know, a lot of likely garbage here, but there's a lot of value here as well, right? We're literally inventing new UIs as we go along and new UI patterns, right? We can just keep going. Check this one out. How cool is this? Okay, so you know, this is the power of an infinite agentic loop: multiple solutions. It's just going to keep going, keep firing. We're using a ton and ton and ton of compute here, right? You can see we're launching another wave of agents inside of this agent, right? One tool call, 30k, 30k, 30k, two minutes each. These are shorter jobs. I've run jobs that are 30 minutes plus, and you can fire them all off in a subtask. It's so incredible what we can do with Claude Code and with the right pattern, right, the right prompting patterns that let us scale compute.

### **Key Takeaways and Principles**

Okay, so really interesting stuff there. What's important? What's the signal here? Right, a couple of things to call out. Um, you can pass prompts into prompts. You can specify variables at the top of your files. You're likely going to want multiple variables that control what happens and what gets done. Okay, we have this infinite, information-dense keyword. This triggers our agentic coding tool to run infinitely. Of course, you need to phrase things, you need to be more specific with how that works. You can start with this prompt and modify it, build it, make it your own.

A couple more key ideas. This is a classic one, right? Um, we have been using plans for over a year now on the channel, and every Principal AI Coding member, you know that great planning is great prompting. I sound like a broken record bringing this up for, you know, over half a year now, but there's a reason for it. Okay, we know that tools will change. We know that models will improve. You can't fixate on these things, right? Claude Code is the very clear winner right now, but it won't always be that way. Okay, and we're going to get another model. All that stuff changes. What doesn't change is the principles of AI coding. Many of you know this is why I built Principled AI Coding. Sorry for existing members and for engineers that have already taken this, but the repetition is probably important anyway. It's so, so important to realize that you want foundational skills that don't change with the next model, with the next tool. The plan, right? Great planning is great prompting. This is principle four or five. This is so relevant. It's increasingly important. Okay, why is that? It's because we can now scale our compute further, right? But how we do that is always about communicating to our agents.

Okay, Claude Code is the best top agent right now for engineering. Why is that? It's because it operates in the highest leverage environment for engineers: the terminal. Anything you can do, Claude Code can do, and you know, part of me wants to say "better." You know, we'll debate that more in the channel as time goes on. It's definitely getting there. Uh, but you can see we're generating yet another batch of agents here. Okay, we have this "Ocean File Explorer," very interesting.

But anyways, refocusing here, right? The spec is super important because this details what we want done inside of this infinite agentic loop, right? So we have this really cool pattern where we're treating our prompts like you can treat functions in certain languages, right? You can pass the function into a function. That's what we're doing here, right? The same idea transferred to this domain of agentic coding and really prompt engineering. We're taking a prompt, passing it into a prompt. You know, the magic is obviously in the pattern of this infinite agentic loop, but it's really in what you ask your spec to do, right? It's what you ask your agent to do. There's a ton and ton of value in this pattern. I hope you can see how powerful this is.

### **When to Use the Infinite Agentic Loop**

When do you want to use something like this? Look at all these UIs we have generating, right? We have two, two, uh, agents going back to back here. Very, very cool. So what, when do you want to use something like this? You want to use a pattern like this, it's very similar again to our parallel agent coding with Git worktrees. There, we cloned our entire codebase into the worktree directory so that multiple agents can work on their own directories. Again, the link for that video is going to be in the description. I highly recommend you check that out.

But what we're doing here is so fascinating, it's so powerful. We're scaling our compute. We're solving a specific problem with many variations of how it can be solved. So when do you want to use the infinite agentic loop? You want to use it when there are multiple potential solutions that you want to explore. You want to use it when you're working on a hard problem that you don't know the answer to, and you think that having many versions will help you get closer. And so this is all stuff you would encode in your lower-level prompt that the infinite agentic loop prompt will execute on, right?

And you want to use this when, this is a really, really big idea, uh, this is like what lead researchers are doing, when you want to set up a self-improving agentic workflow that is trying to achieve some verifiable outcome that increases over time. Okay, we've all heard about reinforcement learning. You can take that idea of reinforcement learning, you can take that idea of self-verifiable domains, and you can embed it in an infinite agentic loop prompt like this. Uh, this is a really, really big idea. More on this on the channel in the future. We don't have enough time to cover that here right now, but that's just really important to call out. Those are kind of the three big use cases for this that I can find right away. I'm sure if you dig into this, if you start using this, you'll find, uh, more, you know, use cases for this, right?

### **Conclusion and Final Thoughts**

So pretty incredible stuff, right? We have two agents running in Claude Code. You can see I am hitting the limit. I'm breaking Claude Code right now. Okay, we're running just straight out of Opus credits. I am running in the Claude Code Max Pro subscription, wherever the top tier is. I'm going to go ahead, I'm going to stop these agents. I need a few more credits for today to, um, do some other engineering work. I'm going to stop these here.

You can see we're literally infinitely generating tons and tons of solutions to this problem, right? That's the trick here, right? That's the real value prop of the infinite agentic loop: you want multiple versions, multiple potential futures of an answer to a problem that you have. Okay, UI is obviously just the simplest one. That's why I've shown it here a couple of times on the channel. Um, you know, we can just keep looking through these different user interfaces with different ideas and themes blended together. Check this one out. Very smooth, very cool. Um, and this is all happening, you know, in the background with compute. We're scaling up doing this.

Again, we're scaling up our compute even further beyond that. That's what we do on the channel every single Monday. Check out Principled AI Coding. As many of you know, I am actively working on the second phase course. This is the foundation. I highly recommend you check this out. What comes next after AI coding is, of course, agentic coding. I'll have more details on the next-generation course as we move closer to the release date. Looking at a Q3 launch, so stay tuned for that.

You know, this is a really powerful technique. Try this, don't ignore this, please, uh, for your own good. Um, you know, it's completely free. A lot of the stuff I'm doing here obviously is all free for you guys. Link in the description to this codebase. I'll save some of these generations so you can kind of really see and understand how this works. But it's really about the infinite prompt. Take all this stuff, make it your own, improve on it, solve your problem better than ever with compute.

Big theme on the channel: to scale your impact, you scale your compute. Okay, tune in, make sure you subscribe, like, all that good stuff. Compute equals success. Scale your compute, you win. You know where to find me every single Monday. Stay focused and keep building.